from __future__ import annotations

from itertools import chain
from typing import Any, TypeVar

T = TypeVar("T")


def wrap_for_pyro(cls: type[T]) -> type[T]:
    """Create proxy class compatible with pyro.

    Some classes, such as those autogenerated by SWIG, may be difficult
    to expose via `Pyro.api.expose`, because Pyro wants to add attributes
    directly to every class and class method that it exposes.  In some
    cases, this leads to an error like:

    AttributeError: 'method_descriptor' object has no attribute '_pyroExposed'

    This wrapper takes a class and returns a proxy class whose methods can
    all be modified.
    """

    def _proxy_method(name: str) -> Any:
        def _f(self: Any, *args: Any, **kwargs: Any) -> Any:
            method = getattr(self._obj, name)
            return method(*args, **kwargs)

        _f.__name__ = name
        return _f

    def _proxy_attr(name: str) -> Any:
        def _f(self: Any, *args: Any, **kwargs: Any) -> Any:
            obj = getattr(self._obj, name)
            return obj

        _f.__name__ = name
        return _f

    _dict_: dict = {}
    for member_name, obj in chain(*(c.__dict__.items() for c in reversed(cls.mro()))):
        if member_name.startswith("_"):
            continue
        if isinstance(obj, property):
            proxy_member = property(_proxy_attr(member_name))
        elif callable(obj):
            proxy_member = _proxy_method(member_name)
            for attr in dir(obj):
                if attr.startswith("_pyro"):
                    setattr(proxy_member, attr, getattr(obj, attr))
        _dict_[member_name] = proxy_member

    def _init_wrap(self: Any, *args: Any, **kwargs: Any) -> None:
        self._obj = cls(*args, **kwargs)

    _dict_["__init__"] = _init_wrap
    return type(f"{cls.__name__}", (), _dict_)
